### **README File Update for Data Structures and Algorithms Portfolio**

#### **1. Problem You Were Solving**
The main problem in these projects was to enhance my understanding and application of **data structures and algorithms**. In **Project One**, I focused on analyzing the **run-time and memory usage** of different data structures, which helped me gain a deeper insight into how these structures perform under various conditions. In **Project Two**, I worked on sorting and displaying a list of **Computer Science courses** in **alphanumeric order**, which required understanding how to efficiently organize and manipulate data.

#### **2. Approach to the Problem**
For **Project One**, I approached the problem by first implementing different data structures, such as **arrays**, **linked lists**, and **trees**, and then performing various operations on them (e.g., insertion, deletion, search). I measured the **time complexity** (run-time) and **space complexity** (memory usage) to understand the trade-offs between using different structures for specific tasks. For **Project Two**, I used **sorting algorithms** like **Merge Sort** or **Quick Sort** to organize the list of courses in a manner that would scale efficiently as the list grows. I also ensured that the implementation was clear, efficient, and reusable.

Data structures are vital to understand because they form the foundation of many algorithms and applications. Whether you're optimizing search performance, improving memory usage, or dealing with large datasets, the right choice of data structure is crucial to the effectiveness of your program.

#### **3. Overcoming Roadblocks**
One of the main challenges I encountered was understanding the **trade-offs** between different data structures and how to accurately analyze their **time and space complexities**. It was a challenge to measure the **run-time** of different data structures in a consistent way, as various factors (e.g., input size, system performance) can affect results. I overcame this by researching best practices for measuring time complexity and using **benchmarking tools** to ensure my results were accurate.

In **Project Two**, the difficulty was primarily around choosing the **best sorting algorithm** for the course list, considering factors like the list's size and whether the order of insertion affected performance. I experimented with different sorting methods, ultimately finding that **Merge Sort** was most efficient for larger datasets, while **Bubble Sort** could be used for smaller ones.

#### **4. Expanding Your Approach to Software Design**
This project expanded my approach to software design by emphasizing **efficiency** and **scalability**. It reinforced the importance of choosing the right data structure and algorithm based on the specific needs of the application. I've learned to prioritize **performance analysis** early in the design phase, ensuring that the system can handle larger datasets or more complex operations without significant slowdowns. Additionally, the importance of **modular design** became clearer, as breaking down complex problems into smaller, manageable parts allows for easier analysis and optimization.

#### **5. Evolving Your Approach to Writing Maintainable, Readable, and Adaptable Programs**
Working through these projects significantly improved the way I approach writing clean and adaptable code. I now pay more attention to **readability** by using meaningful variable names and writing comments to explain the purpose of different sections of code. Furthermore, I’ve adopted a more **modular approach** in my design, ensuring that components are reusable and easy to modify. This makes my code more **maintainable** in the long run. Additionally, I’ve become more mindful of **optimizing** for both **performance** and **memory usage**, understanding that, even in smaller applications, making the right choices can have a big impact.

In summary, these projects have deepened my understanding of how data structures and algorithms play a central role in **optimizing performance** and **scaling** applications. They have also emphasized the need to write code that is both **efficient** and **easy to maintain**.

